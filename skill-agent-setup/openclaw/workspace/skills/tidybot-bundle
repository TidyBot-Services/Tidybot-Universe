#!/usr/bin/env python3
"""
tidybot-bundle: Bundle a skill and its dependencies into a single executable script.

Usage:
    tidybot-bundle <skill-name> [--skills-dir DIR] [--output FILE]

Resolves dependencies from deps.txt, topologically sorts them,
and inlines all code into one self-contained Python script.
"""

import argparse
import os
import sys
from pathlib import Path
from collections import deque


DEFAULT_SKILLS_DIR = Path.home() / ".openclaw/workspace/skills"


def find_skill_dir(skill_name: str, skills_dir: Path) -> Path | None:
    """Find a skill directory by name."""
    candidates = [
        skills_dir / skill_name,
        skills_dir / f"{skill_name}-repo",
    ]
    for candidate in candidates:
        if candidate.is_dir() and (candidate / "main.py").exists():
            return candidate
    return None


def read_deps(skill_dir: Path) -> list[str]:
    """Read dependencies from deps.txt."""
    deps_file = skill_dir / "deps.txt"
    if not deps_file.exists():
        return []
    
    deps = []
    for line in deps_file.read_text().strip().split("\n"):
        line = line.strip()
        if line and not line.startswith("#"):
            deps.append(line)
    return deps


def resolve_dependencies(skill_name: str, skills_dir: Path) -> list[str]:
    """
    Resolve all dependencies in topological order (dependencies first).
    Uses BFS + reverse for correct ordering.
    """
    visited = set()
    order = []
    queue = deque([skill_name])
    
    # BFS to collect all deps
    all_deps = {}  # skill -> [deps]
    while queue:
        current = queue.popleft()
        if current in visited:
            continue
        visited.add(current)
        
        skill_dir = find_skill_dir(current, skills_dir)
        if skill_dir is None:
            print(f"WARNING: Skill '{current}' not found, skipping", file=sys.stderr)
            continue
        
        deps = read_deps(skill_dir)
        all_deps[current] = deps
        
        for dep in deps:
            if dep not in visited:
                queue.append(dep)
    
    # Topological sort using DFS
    visited.clear()
    
    def dfs(name):
        if name in visited:
            return
        visited.add(name)
        for dep in all_deps.get(name, []):
            dfs(dep)
        order.append(name)
    
    dfs(skill_name)
    return order  # Dependencies come before dependents


def extract_code(skill_dir: Path, skill_name: str, is_dependency: bool) -> str:
    """
    Extract code from a skill's main.py.
    For dependencies, skip if __name__ == "__main__" blocks.
    """
    main_py = skill_dir / "main.py"
    if not main_py.exists():
        return f"# ERROR: {skill_name}/main.py not found\n"
    
    code = main_py.read_text()
    
    if is_dependency:
        # Remove if __name__ == "__main__" block from dependencies
        lines = code.split("\n")
        filtered = []
        skip_main = False
        main_indent = 0
        
        for line in lines:
            # Detect start of main block
            stripped = line.strip()
            if stripped.startswith("if __name__") and "__main__" in stripped:
                skip_main = True
                main_indent = len(line) - len(line.lstrip())
                continue
            
            # If we're skipping, check if we've dedented past the main block
            if skip_main:
                if line.strip() == "":
                    continue  # Skip blank lines in main block
                current_indent = len(line) - len(line.lstrip())
                if current_indent <= main_indent and line.strip():
                    skip_main = False  # Dedented, stop skipping
                else:
                    continue  # Still in main block, skip
            
            filtered.append(line)
        
        code = "\n".join(filtered)
    
    return code


def bundle(skill_name: str, skills_dir: Path) -> str:
    """Bundle a skill and all dependencies into one script."""
    order = resolve_dependencies(skill_name, skills_dir)
    
    if not order:
        return f"# ERROR: Could not resolve skill '{skill_name}'\n"
    
    parts = [
        '"""',
        f"Bundled skill: {skill_name}",
        f"Dependencies: {', '.join(order[:-1]) if len(order) > 1 else 'none'}",
        f"Generated by tidybot-bundle",
        '"""',
        "",
    ]
    
    for i, name in enumerate(order):
        skill_dir = find_skill_dir(name, skills_dir)
        if skill_dir is None:
            parts.append(f"# ERROR: Skill '{name}' not found")
            continue
        
        is_dep = (i < len(order) - 1)  # Last one is the main skill
        
        parts.append("")
        parts.append("# " + "=" * 76)
        parts.append(f"# {'DEPENDENCY' if is_dep else 'MAIN'}: {name}")
        parts.append("# " + "=" * 76)
        parts.append("")
        
        code = extract_code(skill_dir, name, is_dependency=is_dep)
        parts.append(code)
    
    return "\n".join(parts)


def main():
    parser = argparse.ArgumentParser(
        description="Bundle a TidyBot skill and its dependencies"
    )
    parser.add_argument("skill", help="Skill name to bundle")
    parser.add_argument(
        "--skills-dir", "-d",
        type=Path,
        default=DEFAULT_SKILLS_DIR,
        help=f"Skills directory (default: {DEFAULT_SKILLS_DIR})"
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        help="Output file (default: stdout)"
    )
    
    args = parser.parse_args()
    
    if not args.skills_dir.is_dir():
        print(f"ERROR: Skills directory not found: {args.skills_dir}", file=sys.stderr)
        sys.exit(1)
    
    result = bundle(args.skill, args.skills_dir)
    
    if args.output:
        args.output.write_text(result)
        print(f"Bundled to {args.output}", file=sys.stderr)
    else:
        print(result)


if __name__ == "__main__":
    main()
